#include "timer0.h"


uint TIME[7]=0; // second minute hour day month week year
uint NAO1[3]=0; // hour minute alarm_bit
uint NAO2[3]=0; // hour minute alarm_bit
uint NAO3[3]=0; // hour minute alarm_bit

uchar ring_s=0;//响铃计时变量
uchar ring_min=0;//响铃计时变量
uchar set_min=3;//设定响铃时间3分钟（最小1分钟）
bit ring_bit=0;//响铃标志位

uchar untouch_s=0;//无操作计时变量
bit mie=0;//oled灭标志位
bit signal=0;//oled熄灭或点亮的动作信号标志位


/************************************************************/
void Timer0Init()//（定时器0）初始化
{
	TMOD|=0x01; //选择为定时器0模式，工作方式1，仅用TR0打开启动
	TH0=0x4c; //给定时器0赋初值，定时50ms（11.0592MHz）
	TL0=0x00;
	ET0=1; //打开定时器0中断允许
	EA=1; //打开总中断
	TR0=1; //打开定时器0	
}


/************************************************************/
void Timer0() interrupt 1
{
	static uchar i=0;
	TH0=0x4c; //重装载
	TL0=0x00;
	i++; //每中断一次(每50ms)，加一次
	

		if(i==20)//周期20*50ms=1s 
			{
					i=0;
					
					if(KeyValue!='T')//修改时间的时候停止走时
					{
						Ds1302ReadTime();//不断从ds1302获取新的TIME0[n]并转换成TIME[n]//(走时的心脏)
					}
					
					/************************************************************************************/
					if(ring_bit==1) //只有正在响铃才计时
					{
						ring_s++;
						if(ring_s==60)//达到一分钟
						{
							ring_s=0;
							ring_min++;
						}
					}
					/************************************************************************************/

					
					/************************************************************************************/
					if( (ring_bit!=1) && (mie!=1) ) untouch_s++;//只有不在响铃且屏幕为亮时才计时
					/************************************************************************************/
					
		
					if(ring_min>=set_min)//到达一定时间自动关闹钟，若手动关闹钟也要记得-复位响铃计时变量
						{
							ring_bit=0;//关闭响铃
							ring_s=0;//复位响铃计时变量
							ring_min=0;//复位响铃计时变量
							untouch_s=0;//响铃结束后无操作计时变量重新计时
						}
					
					if(untouch_s>=30)//无操作到达一定时间
						{
							if( (KeyValue=='T') || (KeyValue=='N') )//到达一定时间自动执行完成修改退出
							{
								KeyValue_plus='D';//完成修改
								untouch_s=0;//复位无操作计时变量
							}
							else if( KeyValue==0 )//到达一定时间自动关闭屏幕省电
							{
								if(mie!=1)//只有oled为亮时才能灭 //保证只可执行一次
									{ mie=1; signal=1; }
								untouch_s=0;//复位无操作计时变量
							}
						}
			}
			
			/************************************************************************************//*放在这检测的精度提高 50ms一次*/
			if( (KL==0) || (KM==0) || (KR==0) ) //有动作untouch_s则重新计时并唤醒屏幕 
				{
					untouch_s=0;//有动作untouch_s则重新计时
					if(mie==1)//只有oled为灭时才能亮 //保证只可执行一次 //此为手动唤醒屏幕
						{ mie=0; signal=1; }
				}
			if( (mie==1) && (ring_bit==1) )//只有oled为灭且正在响铃时才能亮 //保证只可执行一次 //此为自动唤醒屏
		  	{ mie=0; signal=1; }
			/************************************************************************************/
}


/************************************************************************************/
//虽检测真正在于TIMER0中断服务函数，但动作执行必须在于主函数
//（保证oled相关显示程序已被执行完成后才动作，防止其被打断），否则将有机会产生oled的page乱序情况
//以下函数重点在于signal何时为1 才可动作
void XiMie()//oled熄灭检测并执行程序
{            
	if(mie==1)
	if(signal==1)
	{
		OLED_Display_Off();
		signal=0;//动作后signal归零 保证只可动作一次
	}
}
void DianLiang()//oled点亮检测并执行程序
{
	if(mie==0)
	if(signal==1)
	{
		OLED_Display_On();
		signal=0;//动作后signal归零 保证只可动作一次
	}
}
/************************************************************************************/
