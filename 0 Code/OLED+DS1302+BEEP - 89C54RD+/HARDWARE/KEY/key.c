#include "key.h"


uchar KeyValue=0;//为进入时间显示页面初始化
uchar KeyValue_plus=0;//为进入修改页面后可左右移动选择变量所代表的数据初始化
uchar j=1;//工具变量//应用于对-变量q的代表-的初始化问题
uchar q=1;//作用：代表数据（用于修改）//使变量刚开始代表修改页面的第一个数据 //对应数据如下：
//修改时间界面（KeyValue=='T'）---1:(TIME[6]-year)  (TIME[5]-week)  2:(TIME[4]-month)  3:(TIME[3]-day)  4:(TIME[2]-hour)  5:(TIME[1]-minute)  6:(TIME[0]-second) 
//修改闹钟界面（KeyValue=='N'）---1:(NAO1[0]-hour)  2:(NAO1[1]-minute)  3:(NAO1[2]-alarm_bit)
//修改闹钟界面（KeyValue=='N'）---4:(NAO2[0]-hour)  5:(NAO2[1]-minute)  6:(NAO2[2]-alarm_bit)
//修改闹钟界面（KeyValue=='N'）---7:(NAO3[0]-hour)  8:(NAO3[1]-minute)  9:(NAO3[2]-alarm_bit)

//******************************************************************************************************************//		
//******************************************************************************************************************//
//Key_Check_PROS()用于长短按检测（KeyCheck()用于判断KM长按还是短按）并根据不同页面做不同处理（即改变KeyValue和KeyValue_plus的值）

//因为设计闹铃在修改页面不响，所以闹铃触发放在时间页面，而关闭响铃的动作设计则放在Key_Check_PROS里
//即：当闹钟响铃时（ring_bit==1）按下KM按键不进入修改时间或闹钟而是使响铃关闭，正常显示时间
//******************************************************************************************************************//		
//******************************************************************************************************************//


//******************************************************************************************************************//		
//******************************************************************************************************************//
uchar KeyCheck()//判断短按还是长按？
{
	uint i=0;
	
	if(KM==0) //如果按下KM
		{
				delay(1000);    //消抖 延时10ms
				if(KM==0)       //是否真的按下了
				{
					  while( (!KM) && (i<40000)  )i++;     //是否释放按键了 消抖 //i最大加到400ms
						if(i>=20000)       //20000*10us=200ms
								return 'L';//判定为长按   //心里正常默念123即可（实际应该超过400ms，很奇怪）
						else
								return 'S';//判定为短按
				}
				else
				{
					  return 0;//判定为没有按下
				}
		}
	else
		{
			return 0;//判定为没有按下
		}
}

void Key_Check_PROS()//短长按检测并处理函数
{
	uchar Value=0;
	Value=KeyCheck();//判断短按还是长按？
	
	if( (Value!=0) && (ring_bit==1) )//当闹钟响铃按下KM不进入修改时间或闹钟而是使响铃关闭，正常显示时间
		{
			ring_bit=0;//关闭响铃
			ring_s=0;//复位响铃计时变量
			ring_min=0;//复位响铃计时变量
			//*****************************************************************************//
			OLED_DrawBMP(0,0,128,8,IAP_ADDRESS+(2*512));
			delay_ms(20);
			OLED_ShowCHinese(22,3,2);//好
			OLED_ShowCHinese(38,3,3);//滴
			OLED_ShowCHinese(54,3,4);//~
			delay_ms(50);
			OLED_Clear();
			//*****************************************************************************//
			Value=0;//判定为没有按下
		}
		
	if( (Value!=0) && (mie==0) && (signal==1) )//当正在点亮屏幕时按下KM不进入修改时间或闹钟
		{
			Value=0;//判定为没有按下
		}

	if(KeyValue==0)//在显示时间页面
	{
		if(Value==0)KeyValue=0;//判定为没有按下//不变
		if(Value=='S')KeyValue='N';//判定为短按//修改闹钟	
		if(Value=='L')KeyValue='T';//判定为长按//修改时间
	}
	else if( (KeyValue!=0) && (KeyValue_plus==0) )//在修改页面且正在选择修改位
	{
		if(Value==0)KeyValue_plus=0;//判定为没有按下//不变
		if(Value=='S')KeyValue_plus='E';//判定为短按//进入位修改
		if(Value=='L')KeyValue_plus='D';//判定为长按//完成修改退出
	}
	else if(KeyValue_plus=='E')//已进入位修改
	{
		if(Value==0)KeyValue_plus='E';//判定为没有按下//不变
		if(Value=='S')KeyValue_plus=0;//判定为短按//退出位修改->选择修改位
		if(Value=='L')KeyValue_plus='D';//判定为长按//完成修改退出
	}
}
//******************************************************************************************************************//		
//******************************************************************************************************************//


//******************************************************************************************************************//		
//******************************************************************************************************************//
//闰年的计算   
//bit leap_year()   
//{
//	bit leap;   
//	if((year%4==0&&year%100!=0)||year%400==0)//闰年的条件 
//			leap=1;   
//	else   
//			leap=0;   
//	return leap;   
//}  
bit leap_year()   //1:(TIME[6]-year)  (TIME[5]-week)  2:(TIME[4]-month)  3:(TIME[3]-day)  4:(TIME[2]-hour)  5:(TIME[1]-minute)  6:(TIME[0]-second) 
{
	bit leap;   
	if((TIME[6]%4==0&&TIME[6]%100!=0)||TIME[6]%400==0)//闰年的条件 
			leap=1;   
	else   
			leap=0;   
	return leap;   
} 

uint code para_month[13]={0,0,3,3,6,1,4,6,2,5,0,3,5};  //星期月参变数   
//星期的自动运算和处理   
//void week_proc()   
//{
//	uchar num_leap;
//	uchar c;
//	num_leap=year/4-year/100+year/400;//自00年起到year所经历的闰年数
//	if( leap_year()&& month<=2 )   //既是闰年且是1月和2月
//			c=5;   
//	else    
//			c=6;   
//	week=(year+para_month[month]+date+num_leap+c)%7;//计算对应的星期 
//} 
void week_proc()   //1:(TIME[6]-year)  (TIME[5]-week)  2:(TIME[4]-month)  3:(TIME[3]-day)  4:(TIME[2]-hour)  5:(TIME[1]-minute)  6:(TIME[0]-second) 
{
	uint num_leap;
	uint c;
	num_leap=TIME[6]/4-TIME[6]/100+TIME[6]/400;//自00年起到year所经历的闰年数
	if( leap_year()&& TIME[4]<=2 )   //既是闰年且是1月和2月
			c=5;   
	else    
			c=6;   
	TIME[5]=(TIME[6]+para_month[TIME[4]]+TIME[3]+num_leap+c)%7;//计算对应的星期 
} 
//******************************************************************************************************************//		
//******************************************************************************************************************//


void Hexin() //按键操作核心函数
{

//********************************************************0**********************************************************//		
//********************************************************0**********************************************************//	
	Key_Check_PROS();//短长按检测并处理函数

	
//********************************************************1**********************************************修改闹钟************//		
//********************************************************1**********************************************修改闹钟************//	
	if(KeyValue=='N')//修改闹钟
		{
			
			
				if(j==0)//只执行一次 刚从时间显示页面过来才可执行
					{
						q=1;//使变量刚开始代表修改页面的第一个数据
						j=1;
					}

					
				if(KeyValue_plus==0)//可左右移动选择变量所代表的数据
					{
							//********************选中某个时间---NAO1[0]-hour或NAO1[1]-minute或NAO1[2]-alarm_bit********************//
							//********************选中某个时间---NAO2[0]-hour或NAO2[1]-minute或NAO2[2]-alarm_bit********************//		
							//********************选中某个时间---NAO3[0]-hour或NAO3[1]-minute或NAO3[2]-alarm_bit********************//						
							if(KR==0)		  //检测按键KR是否按下                              右移
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KR==0)	 //再次判断按键是否按下
									{
										q++;
										if( q==(9+1) ) q=1; //右移指向可循环
									}
//									while(!KR);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							if(KL==0)		  //检测按键KL是否按下                              左移
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KL==0)	 //再次判断按键是否按下
									{
											q--;
											if( q==(1-1) ) q=9; //左移指向可循环
									}
//									while(!KL);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							//********************************************************************************//
					}
					
				
				if(KeyValue_plus=='E')//进入位修改
					{
							//*****************************对变量所代表的数据进行修改*******************************//
							if(KR==0)		  //检测按键KR是否按下                              加
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KR==0)	 //再次判断按键是否按下
										{
											switch(q)
											{
												case 1: //NAO1[0]-hour
																NAO1[0]++;
																if( NAO1[0]==(23+1) ) NAO1[0]=0; //加24小时循环（0~23）
																break;
												case 2: //NAO1[1]-minute
																NAO1[1]++;
																if( NAO1[1]==(59+1) ) NAO1[1]=0; //加60分钟循环（0~59）
																break;
												case 3: //NAO1[2]-alarm_bit
																NAO1[2]++;
																if( NAO1[2]==(1+1) ) NAO1[2]=0; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
												case 4: //NAO2[0]-hour
																NAO2[0]++;
																if( NAO2[0]==(23+1) ) NAO2[0]=0; //加24小时循环（0~23）
																break;
												case 5: //NAO2[1]-minute
																NAO2[1]++;
																if( NAO2[1]==(59+1) ) NAO2[1]=0; //加60分钟循环（0~59）
																break;
												case 6: //NAO2[2]-alarm_bit
																NAO2[2]++;
																if( NAO2[2]==(1+1) ) NAO2[2]=0; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
												case 7: //NAO3[0]-hour
																NAO3[0]++;
																if( NAO3[0]==(23+1) ) NAO3[0]=0; //加24小时循环（0~23）
																break;
												case 8: //NAO3[1]-minute
																NAO3[1]++;
																if( NAO3[1]==(59+1) ) NAO3[1]=0; //加60分钟循环（0~59）
																break;
												case 9: //NAO3[2]-alarm_bit
																NAO3[2]++;
																if( NAO3[2]==(1+1) ) NAO3[2]=0; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
											}
										}
//									while(!KR);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							if(KL==0)		  //检测按键KL是否按下                              减
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KL==0)	 //再次判断按键是否按下
										{
											switch(q)
											{
												case 1: //NAO1[0]-hour
																NAO1[0]--;
																if( NAO1[0]==(0-1) ) NAO1[0]=23; //加24小时循环（0~23）
																break;
												case 2: //NAO1[1]-minute
																NAO1[1]--;
																if( NAO1[1]==(0-1) ) NAO1[1]=59; //加60分钟循环（0~59）
																break;
												case 3: //NAO1[2]-alarm_bit
																NAO1[2]--;
																if( NAO1[2]==(0-1) ) NAO1[2]=1; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
												case 4: //NAO2[0]-hour
																NAO2[0]--;
																if( NAO2[0]==(0-1) ) NAO2[0]=23; //加24小时循环（0~23）
																break;
												case 5: //NAO2[1]-minute
																NAO2[1]--;
																if( NAO2[1]==(0-1) ) NAO2[1]=59; //加60分钟循环（0~59）
																break;
												case 6: //NAO2[2]-alarm_bit
																NAO2[2]--;
																if( NAO2[2]==(0-1) ) NAO2[2]=1; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
												case 7: //NAO3[0]-hour
																NAO3[0]--;
																if( NAO3[0]==(0-1) ) NAO3[0]=23; //加24小时循环（0~23）
																break;
												case 8: //NAO3[1]-minute
																NAO3[1]--;
																if( NAO3[1]==(0-1) ) NAO3[1]=59; //加60分钟循环（0~59）
																break;
												case 9: //NAO3[2]-alarm_bit
																NAO3[2]--;
																if( NAO3[2]==(0-1) ) NAO3[2]=1; //加2进制循环（0~1）打开或关闭alarm的标志位
																break;
											}
										}
//									while(!KL);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							//********************************************************************************//
					}
				
				
				if(KeyValue_plus=='D')//完成修改
					{
						uchar i=0;
						uchar k=0;
						
						//********************************************************************************//
						IapEraseSector(IAP_ADDRESS+(4*512)); //Erase current sector//擦除第5扇区
						for (i=0; i<3; i++)  //Program 3 bytes data into data flash//将数组 NAO1[3] 的 hour minute alarm_bit 依次写入eeprom
						{
							IapProgramByte(IAP_ADDRESS+(4*512)+k, (uchar)NAO1[i]);
							k++;
						}
						for (i=0; i<3; i++)  //Program 3 bytes data into data flash//将数组 NAO2[3] 的 hour minute alarm_bit 依次写入eeprom
						{
							IapProgramByte(IAP_ADDRESS+(4*512)+k, (uchar)NAO2[i]);
							k++;
						}
						for (i=0; i<3; i++)  //Program 3 bytes data into data flash//将数组 NAO3[3] 的 hour minute alarm_bit 依次写入eeprom
						{
							IapProgramByte(IAP_ADDRESS+(4*512)+k, (uchar)NAO3[i]);
							k++;
						}
						//********************************************************************************//
						
						KeyValue_plus=0;
						KeyValue=0;
						j=0;//使下次从显示时间页面进到修改页面能使变量刚开始代表修改页面的第一个数据
					}
		}
			

//****************************************************************2*************************************修改时间*************//		
//****************************************************************2*************************************修改时间*************//
	if(KeyValue=='T')//修改时间
		{
			
			
				if(j==0)//只执行一次 刚从时间显示页面过来才可执行
					{
						q=1;//使变量刚开始代表修改页面的第一个数据
						j=1;
					}
					
				if(KeyValue_plus==0)//可左右移动选择变量所代表的数据
					{
							//********************选中某个时间---TIME[6]-year或TIME[4]-month或IME[3]-day或TIME[2]-hour或TIME[1]-minute或TIME[0]-second********************//
							if(KR==0)		  //检测按键KR是否按下                              右移
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KR==0)	 //再次判断按键是否按下
									{
										q++;
										if( q==(6+1) ) q=1; //右移指向可循环
									}
//									while(!KR);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							if(KL==0)		  //检测按键KL是否按下                              左移
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KL==0)	 //再次判断按键是否按下
									{
										q--;
										if( q==(1-1) ) q=6; //左移指向可循环
									}
//									while(!KL);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							//********************************************************************************//
					}
					
					
				if(KeyValue_plus=='E')//进入位修改
					{
							//*****************************对变量所代表的数据进行修改*******************************//			
							if(KR==0)		  //检测按键KR是否按下                              加
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KR==0)	 //再次判断按键是否按下
										{
											switch(q)
											{
												case 1: //TIME[6]-year
																TIME[6]++;
																if( TIME[6]==(50+1) ) TIME[6]=0; //加50年循环（0~50）
																break;
												case 2: //TIME[4]-month
																TIME[4]++;
																if( TIME[4]==(12+1) ) TIME[4]=1; //加12月循环（1~12）
																break;
												case 3: //TIME[3]-day
																TIME[3]++;
																if( TIME[4]==1 || TIME[4]==3 || TIME[4]==5 || TIME[4]==7 || TIME[4]==8 || TIME[4]==10 || TIME[4]==12 )//大月
																  if( TIME[3]==(31+1) ) TIME[3]=1;//大月31日循环（1~31）
																if( TIME[4]==4 || TIME[4]==6 || TIME[4]==9 || TIME[4]==11 )//小月   
																  if( TIME[3]==(30+1) ) TIME[3]=1;//小月30日循环（1~30）
																if( TIME[4]==2 )//二月            
																  {
																	 if( leap_year() )//闰年的条件
																		 if( TIME[3]==(29+1) ) TIME[3]=1; //闰年2月29日循环（1~29）
																	 else
																		 if( TIME[3]==(28+1) ) TIME[3]=1; //平年2月28日循环（1~28）
																  }
																break;
												case 4: //TIME[2]-hour
																TIME[2]++;
																if( TIME[2]==(23+1) ) TIME[2]=0; //加24小时循环（0~23）
																break;
												case 5: //TIME[1]-minute
																TIME[1]++;
																if( TIME[1]==(59+1) ) TIME[1]=0; //加60分钟循环（0~59）
																break;
												case 6: //TIME[0]-second
																TIME[0]++;
																if( TIME[0]==(59+1) ) TIME[0]=0; //加60秒循环（0~59）
																break;
											}
											week_proc();//星期自动运算//TIME[5]-week
										}
//									while(!KR);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							if(KL==0)		  //检测按键KL是否按下                              减
								{
									delay(1000);   //消除抖动 一般大约10ms
									if(KL==0)	 //再次判断按键是否按下
										{
											switch(q)
											{
												case 1: //TIME[6]-year
																TIME[6]--;
																if( TIME[6]==(0-1) ) TIME[6]=50; //减50年循环（0~50）
																break;
												case 2: //TIME[4]-month
																TIME[4]--;
																if( TIME[4]==(1-1) ) TIME[4]=12; //加12月循环（1~12）
																break;
												case 3: //TIME[3]-day
																TIME[3]--;
																if( TIME[4]==1 || TIME[4]==3 || TIME[4]==5 || TIME[4]==7 || TIME[4]==8 || TIME[4]==10 || TIME[4]==12 )//大月
																  if( TIME[3]==(1-1) ) TIME[3]=31;//大月31日循环（1~31）
																if( TIME[4]==4 || TIME[4]==6 || TIME[4]==9 || TIME[4]==11 )//小月   
																  if( TIME[3]==(1-1) ) TIME[3]=30;//小月30日循环（1~30）
																if( TIME[4]==2 )//二月            
																  {
																	 if( leap_year() )//闰年的条件
																		 if( TIME[3]==(1-1) ) TIME[3]=29; //闰年2月29日循环（1~29）
																	 else
																		 if( TIME[3]==(1-1) ) TIME[3]=28; //平年2月28日循环（1~28）
																  }
																break;
												case 4: //TIME[2]-hour
																TIME[2]--;
																if( TIME[2]==(0-1) ) TIME[2]=23; //加24小时循环（0~23）
																break;
												case 5: //TIME[1]-minute
																TIME[1]--;
																if( TIME[1]==(0-1) ) TIME[1]=59; //加60分钟循环（0~59）
																break;
												case 6: //TIME[0]-second
																TIME[0]--;
																if( TIME[0]==(0-1) ) TIME[0]=59; //加60秒循环（0~59）
																break;
											}
											week_proc();//星期自动运算//TIME[5]-week
										}
//									while(!KL);	 //检测按键是否松开
									delay(20000);   //消除抖动 支持连续按 间隔200ms
								}
							//********************************************************************************//
					}
			
	
				if(KeyValue_plus=='D')//完成修改
					{
						Ds1302Init();//把刚修改的TIME转换TIME0存到DS1302
						
						KeyValue_plus=0;
						KeyValue=0;//此句需在TIME[7]写入DS1302程序的后面！避免数据还没写入DS1302就被定时器0从DS1302获取的旧数据覆盖了
						j=0;//使下次从显示时间页面进到修改页面能使变量刚开始代表修改页面的第一个数据
					}
		}


}
